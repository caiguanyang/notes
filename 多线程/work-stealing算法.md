<meta http-equiv="content-type" content="text/html; charset=UTF-8">

T:14-05-20

work-stealing算法
-----------------
###1. 步骤
每一个工作线程维护自己的调度队列中的可运行任务。  
队列以双端队列的形式被维护（注：deques通常读作“decks”），不仅支持后进先出——LIFO的push和pop操作，还支持先进先出——FIFO的take操作。  

对于一个给定的工作线程来说，任务所产生的子任务将会被放入到工作者自己的双端队列中。  

工作线程使用后进先出——LIFO(最早的优先)的顺序，通过弹出任务来处理队列中的任务。  

当一个工作线程的本地没有任务去运行的时候，它将使用先进先出——FIFO的规则尝试随机的从别的工作线程中拿（“偷窃”）一个任务去运行。  

当一个工作线程触及了join操作，如果可能的话它将处理其他任务，直到目标任务被告知已经结束（通过isDone方法）。所有的任务都会无阻塞的完成。  

当一个工作线程无法再从其他线程中获取任务和失败处理的时候，它就会退出（通过yields, sleeps, 和/或者优先级调整，参考第3节）并经过一段时间之后再度尝试直到所有的工作线程都被告知他们都处于空闲的状态。在这种情况下，他们都会阻塞直到其他的任务再度被上层调用。  



###2. 算法优点
1） 让偷取任务的线程从队列拥有者相反的方向进行操作会减少线程竞；  
**问题：**具体如何实现，当队列中只有1个任务时，且工作线程和窃取任务的线程都试图访问，如何处理冲突？  

2）由于偷取的任务时工作线程早期放入的任务，粒度还是比较大的，这样窃取线程获取任务后需要进行递归分解，这样就会有许多小任务可以执行，减少了窃取的次数。也是一种优化。  
**问题：**工作线程的任务队列是如何暴漏出去的？  


