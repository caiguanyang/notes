<meta http-equiv="content-type" content="text/html; charset=UTF-8">

T：2014-06-06 
tomato:

java锁机制
----------------------
###1. volatile
&emsp;&emsp;修饰变量，保证其“可见性”， 由于java的内存模型允许每个线程有自己的内存空间，虚拟机可能在线程内保存变量的副本，那么当多个线程都同时改变量时，可能修改的只是自身的副本，没有及时刷新到主存中，这样导致自身的修改对别的线程不可见，而出现不一致情况。volatile解决了此内存模型带来的问题，但是它仅仅是解决了可见性问题；  
&emsp;&emsp;在多线程场景下，只有对volatile变量的操作时原子的，才能解决同步性问题，否则还需要使用其他同步机制。像i++, i--操作都不是原子操作，要注意Java的语法糖。

###2. synchronized
1）修饰普通方法：每个线程执行此方法前，要先获得此方法所属对象的锁，否则被阻塞（java中没有对象都有一个锁和它绑定）。  
2）修改代码块：进入此代码块之前，需获得对象锁；  
3）修饰静态方法：执行静态方法前，需获得类唯一的锁（class对象的锁）；  
特征：  
1）对象锁具有可重入特性，同一个线程在获得对象锁后，还可以执行其他的同步方法；  
2）线程A执行普通同步方法后，线程B仍然可以执行同步的静态方法，因为它们两个是不同的对象锁。  

###3. ThreadLocal
&emsp;&emsp;ThreadLocal变量指线程本地变量，通过get和set来获取和设定；每个线程在使用时都会创建一个Map来保存本地变量值的引用，访问时从当前线程独有的Map中查找此变量的值。当然如果为ThreadLocal变量设定的为一个共享对象(如一个静态的Vector)，那么多个线程间也将出现争夺资源访问的情况。  
参考总结的“ThreadLocal原理介绍”

###4. 原子变量


###5. 条件变量


###6. 信号量


###7. Lock
与synchronized相似，只是我们需要显示定义一个锁，并使用Lock接口的lock(), unlock()方法获取和释放锁。因此使用起来要比synchronized麻烦，但是它更灵活一些，如一个锁可以被多个线程使用，一个线程也可以显示依赖多个锁，支持比synchronized更多的场景；  
&emsp;&emsp;当然在synchronized和lock都能满足需求的情况下，开发人员可以根据自己的爱好选择某个机制来实现。

###8. 闭锁


###9. 栅栏